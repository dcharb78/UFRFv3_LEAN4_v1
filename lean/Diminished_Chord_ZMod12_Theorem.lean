import Mathlib.Data.ZMod.Basic
import Mathlib.Tactic

import CycleStep_Orbit_Theorem

/-!
# Diminished Chord (0,3,6,9) as a 4-State Invariant in `ZMod 12`

User-facing intuition (music / overlap lens):
- Working mod `12` (the chromatic cycle), stepping by `3` cycles through exactly 4 states:
  `0 → 3 → 6 → 9 → 0`.

This file makes that precise in Lean as exact modular arithmetic on `ZMod 12`.

This is **not** a universal claim about all moduli; it is the specific 4-cycle generated by the
additive step `+3` in `ℤ/12ℤ`.
-/

namespace DiminishedChordZMod12

/-- The 4-state orbit (a.k.a. diminished seventh chord) inside `ZMod 12`. -/
def chord : Finset (ZMod 12) := {0, 3, 6, 9}

theorem mem_chord_iff (x : ZMod 12) :
    x ∈ chord ↔ x = 0 ∨ x = 3 ∨ x = 6 ∨ x = 9 := by
  simp [chord]

/-- Explicit 4-step return: repeated addition of `3` closes after 4 moves. -/
abbrev three_nsmul_cycle_statement : Prop :=
    (0 • (3 : ZMod 12) = 0) ∧
    (1 • (3 : ZMod 12) = 3) ∧
    (2 • (3 : ZMod 12) = 6) ∧
    (3 • (3 : ZMod 12) = 9) ∧
    (4 • (3 : ZMod 12) = 0)

/-- Explicit 4-step return: repeated addition of `3` closes after 4 moves. -/
theorem three_nsmul_cycle : three_nsmul_cycle_statement := by
  native_decide

/--
Exact order (minimality):

In `ZMod 12`, stepping by `+3` returns after `n` steps **iff** `4 ∣ n`.
-/
theorem nsmul_step3_eq_zero_iff_four_dvd (n : Nat) :
    n • (3 : ZMod 12) = 0 ↔ 4 ∣ n := by
  have hm : 0 < 12 := by decide
  -- `n•s=0 ↔ orbitSize ∣ n`, and `orbitSize 12 3 = 4`.
  have hos : CycleStepOrbit.orbitSize 12 3 = 4 := by native_decide
  simpa [hos] using
    (CycleStepOrbit.nsmul_eq_zero_iff_orbitSize_dvd (m := 12) (s := 3) (n := n) hm)

/-- Invariance: the chord is closed under the step `x ↦ x + 3`. -/
theorem chord_invariant_add_three (x : ZMod 12) (hx : x ∈ chord) : x + 3 ∈ chord := by
  have hx' : x = 0 ∨ x = 3 ∨ x = 6 ∨ x = 9 := (mem_chord_iff x).1 hx
  rcases hx' with rfl | rfl | rfl | rfl <;> native_decide

/-!
## Scaled diminished chord (ratio-only)

If we scale the chromatic modulus by a factor `k`, the same 4-state structure persists:

`ZMod (12*k)` with step `3*k` cycles through exactly
`{0, 3k, 6k, 9k}` and returns after 4 moves.

This captures the repo's "scale invariance" intent: the structure depends on the ratio
`(3k)/(12k) = 1/4`, not the absolute size.
-/

/-- The scaled 4-state orbit inside `ZMod (12*k)`. -/
def chordScaled (k : Nat) : Finset (ZMod (12 * k)) :=
  { (0 : ZMod (12 * k)),
    ((3 * k : Nat) : ZMod (12 * k)),
    ((6 * k : Nat) : ZMod (12 * k)),
    ((9 * k : Nat) : ZMod (12 * k)) }

theorem mem_chordScaled_iff (k : Nat) (x : ZMod (12 * k)) :
    x ∈ chordScaled k ↔
      x = (0 : ZMod (12 * k))
        ∨ x = ((3 * k : Nat) : ZMod (12 * k))
        ∨ x = ((6 * k : Nat) : ZMod (12 * k))
        ∨ x = ((9 * k : Nat) : ZMod (12 * k)) := by
  simp [chordScaled]

/-- Explicit 4-step return at any positive scale `k`: `0 → 3k → 6k → 9k → 0`. -/
abbrev three_nsmul_cycle_scaled_statement : Prop :=
    ∀ {k : Nat}, 0 < k →
      (0 • (((3 * k : Nat) : ZMod (12 * k))) = 0) ∧
      (1 • (((3 * k : Nat) : ZMod (12 * k))) = ((3 * k : Nat) : ZMod (12 * k))) ∧
      (2 • (((3 * k : Nat) : ZMod (12 * k))) = ((6 * k : Nat) : ZMod (12 * k))) ∧
      (3 • (((3 * k : Nat) : ZMod (12 * k))) = ((9 * k : Nat) : ZMod (12 * k))) ∧
      (4 • (((3 * k : Nat) : ZMod (12 * k))) = 0)

/-- Explicit 4-step return at any positive scale `k`: `0 → 3k → 6k → 9k → 0`. -/
theorem three_nsmul_cycle_scaled : three_nsmul_cycle_scaled_statement := by
  intro k hk
  let a : ZMod (12 * k) := ((3 * k : Nat) : ZMod (12 * k))
  refine And.intro ?_ (And.intro ?_ (And.intro ?_ (And.intro ?_ ?_)))
  · simp
  · simp
  · -- `2 • (3k) = 6k`
    have h : (2 : Nat) * (3 * k) = 6 * k := by ring
    calc
      (2 • a) = ((2 : Nat) : ZMod (12 * k)) * a := by
            simp [a, nsmul_eq_mul]
      _ = ((2 * (3 * k) : Nat) : ZMod (12 * k)) := by
            simp [a, Nat.cast_mul]
      _ = ((6 * k : Nat) : ZMod (12 * k)) := by
            simp [h]
  · -- `3 • (3k) = 9k`
    have h : (3 : Nat) * (3 * k) = 9 * k := by ring
    calc
      (3 • a) = ((3 : Nat) : ZMod (12 * k)) * a := by
            simp [a, nsmul_eq_mul]
      _ = ((3 * (3 * k) : Nat) : ZMod (12 * k)) := by
            simp [a, Nat.cast_mul]
      _ = ((9 * k : Nat) : ZMod (12 * k)) := by
            simp [h]
  · -- `4 • (3k) = 0` because `4*(3k) = 12*k` is the modulus.
    have h : (4 : Nat) * (3 * k) = 12 * k := by ring
    calc
      (4 • a) = ((4 : Nat) : ZMod (12 * k)) * a := by
            simp [a, nsmul_eq_mul]
      _ = ((4 * (3 * k) : Nat) : ZMod (12 * k)) := by
            simp [a, Nat.cast_mul]
      _ = ((12 * k : Nat) : ZMod (12 * k)) := by
            simp [h]
      _ = 0 := by simp

/--
Exact order (scaled diminished chord):

For any `k > 0`, in `ZMod (12*k)` stepping by `+(3*k)` returns after `n` steps **iff** `4 ∣ n`.

This is a strict strengthening of the 4-step return: it says there is no earlier closure.
-/
theorem nsmul_step3k_eq_zero_iff_four_dvd {k n : Nat} (hk : 0 < k) :
    n • ((3 * k : Nat) : ZMod (12 * k)) = 0 ↔ 4 ∣ n := by
  have hm : 0 < 12 * k := Nat.mul_pos (by decide : 0 < 12) hk
  -- `n•s=0 ↔ orbitSize ∣ n`, and `orbitSize (12*k) (3*k) = 4` by scale invariance.
  have hos : CycleStepOrbit.orbitSize (12 * k) (3 * k) = 4 := by
    have hscale :
        CycleStepOrbit.orbitSize (k * 12) (k * 3) = CycleStepOrbit.orbitSize 12 3 :=
      CycleStepOrbit.orbitSize_scale_invariant (k := k) (m := 12) (s := 3) hk
    have hos' : CycleStepOrbit.orbitSize (12 * k) (3 * k) = CycleStepOrbit.orbitSize 12 3 := by
      simpa [Nat.mul_comm, Nat.mul_assoc, Nat.mul_left_comm] using hscale
    have h123 : CycleStepOrbit.orbitSize 12 3 = 4 := by native_decide
    exact hos'.trans h123
  simpa [hos] using
    (CycleStepOrbit.nsmul_eq_zero_iff_orbitSize_dvd (m := 12 * k) (s := 3 * k) (n := n) hm)

/-- Invariance at scale `k`: the scaled chord is closed under the step `x ↦ x + (3k)`. -/
theorem chordScaled_invariant_add_three (k : Nat) (x : ZMod (12 * k)) (hx : x ∈ chordScaled k) :
    x + ((3 * k : Nat) : ZMod (12 * k)) ∈ chordScaled k := by
  let a : ZMod (12 * k) := ((3 * k : Nat) : ZMod (12 * k))
  have hx' :
      x = (0 : ZMod (12 * k))
        ∨ x = ((3 * k : Nat) : ZMod (12 * k))
        ∨ x = ((6 * k : Nat) : ZMod (12 * k))
        ∨ x = ((9 * k : Nat) : ZMod (12 * k)) := (mem_chordScaled_iff k x).1 hx
  rcases hx' with rfl | rfl | rfl | rfl
  · -- `0 + 3k = 3k`
    have : (0 : ZMod (12 * k)) + a = ((3 * k : Nat) : ZMod (12 * k)) := by
      simp [a]
    -- show membership via the characterization lemma
    refine (mem_chordScaled_iff k ((0 : ZMod (12 * k)) + a)).2 ?_
    exact Or.inr (Or.inl this)
  · -- `3k + 3k = 6k`
    have h : (3 * k : Nat) + 3 * k = 6 * k := by ring
    have hadd :
        ((3 * k : Nat) : ZMod (12 * k)) + ((3 * k : Nat) : ZMod (12 * k)) =
          ((6 * k : Nat) : ZMod (12 * k)) := by
      calc
        ((3 * k : Nat) : ZMod (12 * k)) + ((3 * k : Nat) : ZMod (12 * k)) =
            ((3 * k + 3 * k : Nat) : ZMod (12 * k)) := by
              exact (Nat.cast_add (R := ZMod (12 * k)) (3 * k) (3 * k)).symm
        _ = ((6 * k : Nat) : ZMod (12 * k)) := by
              simp [h]
    refine (mem_chordScaled_iff k (((3 * k : Nat) : ZMod (12 * k)) + a)).2 ?_
    refine Or.inr (Or.inr (Or.inl ?_))
    simpa [a] using hadd
  · -- `6k + 3k = 9k`
    have h : (6 * k : Nat) + 3 * k = 9 * k := by ring
    have hadd :
        ((6 * k : Nat) : ZMod (12 * k)) + ((3 * k : Nat) : ZMod (12 * k)) =
          ((9 * k : Nat) : ZMod (12 * k)) := by
      calc
        ((6 * k : Nat) : ZMod (12 * k)) + ((3 * k : Nat) : ZMod (12 * k)) =
            ((6 * k + 3 * k : Nat) : ZMod (12 * k)) := by
              exact (Nat.cast_add (R := ZMod (12 * k)) (6 * k) (3 * k)).symm
        _ = ((9 * k : Nat) : ZMod (12 * k)) := by
              simp [h]
    refine (mem_chordScaled_iff k (((6 * k : Nat) : ZMod (12 * k)) + a)).2 ?_
    refine Or.inr (Or.inr (Or.inr ?_))
    simpa [a] using hadd
  · -- `9k + 3k = 12k = 0`
    have h : (9 * k : Nat) + 3 * k = 12 * k := by ring
    have hadd :
        ((9 * k : Nat) : ZMod (12 * k)) + ((3 * k : Nat) : ZMod (12 * k)) = 0 := by
      calc
        ((9 * k : Nat) : ZMod (12 * k)) + ((3 * k : Nat) : ZMod (12 * k)) =
            ((9 * k + 3 * k : Nat) : ZMod (12 * k)) := by
              exact (Nat.cast_add (R := ZMod (12 * k)) (9 * k) (3 * k)).symm
        _ = ((12 * k : Nat) : ZMod (12 * k)) := by
              simp [h]
        _ = 0 := by simp
    refine (mem_chordScaled_iff k (((9 * k : Nat) : ZMod (12 * k)) + a)).2 ?_
    refine Or.inl ?_
    simpa [a] using hadd

end DiminishedChordZMod12
