import Mathlib

/-!
# Small-World Traversal on the 13-Cycle (Overlap + Flip)

This file formalizes a clean, *discrete* version of the "small-world" claim from the UFRF notes:

* **Overlap** = local adjacency steps `±1` on the 13-cycle.
* **Flip** = a long-range step `±6` (half-cycle) on the 13-cycle.

Model: the Cayley graph of `ZMod 13` generated by `{±1, ±6}`.

Certified facts (no placeholders):

1. Every residue in `ZMod 13` is reachable from `0` in **≤ 3** such steps.
2. The residue `3` is **not** reachable in **≤ 2** such steps (so the bound is nontrivial).

This exactly captures “overlap + flip = shortcuts”: adding a half-cycle jump drastically reduces
the maximum number of moves needed to traverse the cycle.
-/

namespace SmallWorldOverlapFlip

open scoped BigOperators

/-- The 13-cycle state space. -/
abbrev C13 := ZMod 13

/-!
## Step set

We use the literal generator set `{±1, ±6}` in `ZMod 13`.
-/

def steps : Finset C13 := { (1 : C13), (-1 : C13), (6 : C13), (-6 : C13) }

/-!
## Non-reachability in ≤ 2

For `w.length ≤ 2`, the list is either `[]`, `[a]`, or `[a,b]`.
With the generator set `{±1, ±6}`, none of these sums can equal `3`.
-/

theorem not_reachable_three_in_two (w : List C13) (hwlen : w.length ≤ 2) (hwstep : ∀ x ∈ w, x ∈ steps) :
    w.sum ≠ (3 : C13) := by
  cases w with
  | nil =>
      simpa using (by decide : ((0 : C13) ≠ (3 : C13)))
  | cons a w1 =>
      cases w1 with
      | nil =>
          have ha : a ∈ steps := hwstep a (by simp)
          -- `a` is one of `{±1, ±6}`.
          have ha_cases : a = (1 : C13) ∨ a = (-1 : C13) ∨ a = (6 : C13) ∨ a = (-6 : C13) := by
            simpa [steps, Finset.mem_insert, Finset.mem_singleton] using ha
          rcases ha_cases with ha1 | ha2
          · -- `a = 1`
            simpa [ha1] using (by decide : ((1 : C13) ≠ (3 : C13)))
          rcases ha2 with ha2 | ha3
          · -- `a = -1`
            simpa [ha2] using (by decide : ((-1 : C13) ≠ (3 : C13)))
          rcases ha3 with ha3 | ha4
          · -- `a = 6`
            simpa [ha3] using (by decide : ((6 : C13) ≠ (3 : C13)))
          · -- `a = -6`
            simpa [ha4] using (by decide : ((-6 : C13) ≠ (3 : C13)))
      | cons b w2 =>
          cases w2 with
          | nil =>
              have ha : a ∈ steps := hwstep a (by simp)
              have hb : b ∈ steps := hwstep b (by simp)
              have ha_cases : a = (1 : C13) ∨ a = (-1 : C13) ∨ a = (6 : C13) ∨ a = (-6 : C13) := by
                simpa [steps, Finset.mem_insert, Finset.mem_singleton] using ha
              have hb_cases : b = (1 : C13) ∨ b = (-1 : C13) ∨ b = (6 : C13) ∨ b = (-6 : C13) := by
                simpa [steps, Finset.mem_insert, Finset.mem_singleton] using hb
              rcases ha_cases with ha1 | ha2
              · rcases hb_cases with hb1 | hb2
                · simpa [ha1, hb1] using (by decide : ((1 : C13) + (1 : C13) ≠ (3 : C13)))
                rcases hb2 with hb2 | hb3
                · simpa [ha1, hb2] using (by decide : ((1 : C13) + (-1 : C13) ≠ (3 : C13)))
                rcases hb3 with hb3 | hb4
                · simpa [ha1, hb3] using (by decide : ((1 : C13) + (6 : C13) ≠ (3 : C13)))
                · simpa [ha1, hb4] using (by decide : ((1 : C13) + (-6 : C13) ≠ (3 : C13)))
              rcases ha2 with ha2 | ha3
              · rcases hb_cases with hb1 | hb2
                · simpa [ha2, hb1] using (by decide : ((-1 : C13) + (1 : C13) ≠ (3 : C13)))
                rcases hb2 with hb2 | hb3
                · simpa [ha2, hb2] using (by decide : ((-1 : C13) + (-1 : C13) ≠ (3 : C13)))
                rcases hb3 with hb3 | hb4
                · simpa [ha2, hb3] using (by decide : ((-1 : C13) + (6 : C13) ≠ (3 : C13)))
                · simpa [ha2, hb4] using (by decide : ((-1 : C13) + (-6 : C13) ≠ (3 : C13)))
              rcases ha3 with ha3 | ha4
              · rcases hb_cases with hb1 | hb2
                · simpa [ha3, hb1] using (by decide : ((6 : C13) + (1 : C13) ≠ (3 : C13)))
                rcases hb2 with hb2 | hb3
                · simpa [ha3, hb2] using (by decide : ((6 : C13) + (-1 : C13) ≠ (3 : C13)))
                rcases hb3 with hb3 | hb4
                · simpa [ha3, hb3] using (by decide : ((6 : C13) + (6 : C13) ≠ (3 : C13)))
                · simpa [ha3, hb4] using (by decide : ((6 : C13) + (-6 : C13) ≠ (3 : C13)))
              · rcases hb_cases with hb1 | hb2
                · simpa [ha4, hb1] using (by decide : ((-6 : C13) + (1 : C13) ≠ (3 : C13)))
                rcases hb2 with hb2 | hb3
                · simpa [ha4, hb2] using (by decide : ((-6 : C13) + (-1 : C13) ≠ (3 : C13)))
                rcases hb3 with hb3 | hb4
                · simpa [ha4, hb3] using (by decide : ((-6 : C13) + (6 : C13) ≠ (3 : C13)))
                · simpa [ha4, hb4] using (by decide : ((-6 : C13) + (-6 : C13) ≠ (3 : C13)))
          | cons c w3 =>
              -- Contradiction: length is at least 3, but we assumed `≤ 2`.
              have hge : (3 : Nat) ≤ (a :: b :: c :: w3).length := by
                simp
              have h32 : ¬ (3 ≤ (2 : Nat)) := by decide
              exact (h32 (le_trans hge hwlen)).elim

/-!
## Reachability in ≤ 3

We give explicit witnesses for each residue (as `Fin 13`) and check the arithmetic by computation.
-/

theorem reachable_all_in_three :
    ∀ d : Fin 13,
      ∃ w : List C13, w.length ≤ 3 ∧ (∀ x ∈ w, x ∈ steps) ∧ w.sum = ((d : Nat) : C13) := by
  intro d
  fin_cases d
  · refine ⟨[], ?_, ?_, ?_⟩ <;> simp [steps]
  · refine ⟨[1], by decide, by simp [steps], by decide⟩
  · refine ⟨[1, 1], by decide, by simp [steps], by decide⟩
  · refine ⟨[1, 1, 1], by decide, by simp [steps], by decide⟩
  · refine ⟨[6, -1, -1], by decide, by simp [steps], by decide⟩
  · refine ⟨[6, -1], by decide, by simp [steps], by decide⟩
  · refine ⟨[6], by decide, by simp [steps], by decide⟩
  · refine ⟨[-6], by decide, by simp [steps], by decide⟩
  · refine ⟨[-6, 1], by decide, by simp [steps], by decide⟩
  · refine ⟨[-6, 1, 1], by decide, by simp [steps], by decide⟩
  · refine ⟨[-1, -1, -1], by decide, by simp [steps], by decide⟩
  · refine ⟨[-1, -1], by decide, by simp [steps], by decide⟩
  · refine ⟨[-1], by decide, by simp [steps], by decide⟩

/--
Main packaged statement:

* every residue is reachable in `≤ 3` steps from `{±1, ±6}`,
* but `3` is not reachable in `≤ 2` such steps.
-/
theorem overlap_flip_small_world :
    (∀ d : Fin 13,
      ∃ w : List C13, w.length ≤ 3 ∧ (∀ x ∈ w, x ∈ steps) ∧ w.sum = ((d : Nat) : C13))
    ∧
    (∀ w : List C13, w.length ≤ 2 → (∀ x ∈ w, x ∈ steps) → w.sum ≠ (3 : C13)) := by
  constructor
  · exact reachable_all_in_three
  · intro w hwlen hwstep
    exact not_reachable_three_in_two w hwlen hwstep

/-!
`overlap_flip_small_world` is a *proof term*, so when other files want the **statement**
as a `Prop` (e.g. to include it as a conjunct in a larger theorem), they should use the
definition below.
-/

/-- The statement of `overlap_flip_small_world`, packaged as a `Prop`. -/
def overlap_flip_small_world_stmt : Prop :=
    (∀ d : Fin 13,
      ∃ w : List C13, w.length ≤ 3 ∧ (∀ x ∈ w, x ∈ steps) ∧ w.sum = ((d : Nat) : C13))
    ∧
    (∀ w : List C13, w.length ≤ 2 → (∀ x ∈ w, x ∈ steps) → w.sum ≠ (3 : C13))

theorem overlap_flip_small_world_stmt_proven : overlap_flip_small_world_stmt := by
  simpa [overlap_flip_small_world_stmt] using overlap_flip_small_world

end SmallWorldOverlapFlip
